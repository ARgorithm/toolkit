<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ARgorithmToolkit.linkedlist API documentation</title>
<meta name="description" content="The linkedlist module provides support for rendering linked lists …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="stylesheet" href="../css/font-awesome.css">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ARgorithmToolkit.linkedlist</code></h1>
</header>
<section id="section-intro">
<p>The linkedlist module provides support for rendering linked lists.</p>
<p>linkedlist module provides a wrapper for your LinkedList nodes useful for
explanation and the Forwardlist class which is useful for application.</p>
<ul>
<li>The LinkedListNode class is used to represent a node.</li>
<li>The LinkedList class is used to store the head pointer.</li>
<li>The ForwardList class is a complete implementation of singly linked list</li>
</ul>
<p>These three classes can be directly imported from the toolkit:</p>
<pre><code>&gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
&gt;&gt;&gt; ll = ARgorithmToolkit.LinkedList("llnode",algo,llnode)
&gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList("fl",algo)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The linkedlist module provides support for rendering linked lists.

linkedlist module provides a wrapper for your LinkedList nodes useful for
explanation and the Forwardlist class which is useful for application.

- The LinkedListNode class is used to represent a node.
- The LinkedList class is used to store the head pointer.
- The ForwardList class is a complete implementation of singly linked list

These three classes can be directly imported from the toolkit:

    &gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
    &gt;&gt;&gt; ll = ARgorithmToolkit.LinkedList(&#34;llnode&#34;,algo,llnode)
    &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)

&#34;&#34;&#34;

from ARgorithmToolkit.utils import State, StateSet, ARgorithmError

class LinkedListNodeState:
    &#34;&#34;&#34;This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedListNode`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
    &#34;&#34;&#34;

    def __init__(self,name:str):
        self.name = name

    def llnode_declare(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_declare` state when a new node is created.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_declare` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_declare&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_iter(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_iter` state when a node is accessed or its
        value is changed.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_iter` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_iter&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_next(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_next` state when the next pointer changes.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_next` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_next&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_delete(self,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_delete` state when a node is deleted.

        Args:
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_delete` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_delete&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

class LinkedListNode:
    &#34;&#34;&#34;The LinkedListNode class is an implementation of a Linked list Node for
    which we store states. Unlike other data structure classes, in which we
    have to give a name to the instance, we dont have to provide name in the
    LinkedListNode Class.

    Attributes:
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedListNode Class
        value: The value stored in the node
        next (LinkedListNode): The reference to next node

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; llnode.value = 10
        &gt;&gt;&gt; temp = = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; temp.next = llnode
        &gt;&gt;&gt; llnode = temp

    &#34;&#34;&#34;

    def __init__(self,algo:StateSet,value=None,comments=&#34;&#34;):
        self.name = id(self)
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError(&#34;algo should be of type StateSet&#34;) from e

        self.state_generator = LinkedListNodeState(self.name)

        self._flag = False
        self.value = value
        self.next = None
        self._flag = True

        state = self.state_generator.llnode_declare(
            self.value,self.next,comments
        )
        self.algo.add_state(state)

    def __setattr__(self,key,value):
        &#34;&#34;&#34;The __setattr__ function is overriden to listen to state changes in
        the value of node or the next attribute.

        Raises:
            ARgorithmError: Raised if next pointer is not type None or LinkedListNode
        &#34;&#34;&#34;
        if key == &#39;next&#39; and value:
            assert isinstance(value,LinkedListNode) , ARgorithmError(&#34;next should be of type None or LinkedListNode&#34;)
        self.__dict__[key] = value
        if key == &#39;next&#39; and self._flag:
            if value or self.next:
                state = self.state_generator.llnode_next(
                    self.value,
                    self.next,
                    &#34;next pointer updated&#34;
                )
                self.algo.add_state(state)
        elif key == &#39;value&#39; and self._flag:
            state = self.state_generator.llnode_iter(
                self.value,
                self.next,
                &#34;value updated&#34;
            )
            self.algo.add_state(state)

    def __del__(self):
        &#34;&#34;&#34;The __del__ function is overriden is there to listen to node
        deletion.&#34;&#34;&#34;
        state = self.state_generator.llnode_delete(
            &#34;Node was deleted&#34;
        )
        self.algo.add_state(state)

    def __str__(self):
        return f&#34;LinkedListNode({self.value}) at {self.name}&#34;

    def __repr__(self):
        return f&#34;LinkedListNode({self.value}) at {self.name}&#34;

class LinkedListState:
    &#34;&#34;&#34;This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedList`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
    &#34;&#34;&#34;
    def __init__(self,name:str):
        self.name = name

    def ll_declare(self,head,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `ll_declare` state when a new linkedlist is created.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `ll_declare` state
        &#34;&#34;&#34;
        state_type = &#34;ll_declare&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;head&#34; : head.name if head else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def ll_head(self,head,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `ll_head` state when linkedlist head is changed.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `ll_head` state
        &#34;&#34;&#34;
        state_type = &#34;ll_head&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;head&#34; : head.name if head else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

class LinkedList:
    &#34;&#34;&#34;The LinkedList class is used to just store the head of the linked list.

    This class is useful when programmer want to program his own List class using
    the nodes. Only contains head attribute and no methods

    Attributes:
        name (str): The name given to the linkedlist
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedList Class
        head (LinkedListNode): The referece to head of linkedlist

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; ll = ARgorithmToolkit.LinkedList(&#34;llnode&#34;,algo)
        &gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; ll.head = llnode

    &#34;&#34;&#34;

    def __init__(self,name:str,algo:StateSet,head=None,comments=&#34;&#34;):

        assert isinstance(name,str) , ARgorithmError(&#34;Name should be of type string&#34;)
        self.name = name
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError(&#34;algo should be of type StateSet&#34;) from e
        self.state_generator = LinkedListState(self.name)

        self._flag = False
        if head:
            assert self.algo == head.algo, ARgorithmError(&#34;The head node belongs to a different StateSet&#34;)
        self.head = head
        self._flag = True

        state = self.state_generator.ll_declare(self.head,comments)
        self.algo.add_state(state)

    def __setattr__(self,key,value):
        &#34;&#34;&#34;The __setattr__ function is overriden to listen to state changes in
        the head.

        Raises:
            ARgorithmError: Raised if head pointer is not type None or LinkedListNode
        &#34;&#34;&#34;
        if key == &#39;head&#39; and value:
            assert isinstance(value,LinkedListNode) , ARgorithmError(&#34;next should be of type None or LinkedListNode&#34;)
        self.__dict__[key] = value
        if key == &#39;head&#39; and self._flag:
            state = self.state_generator.ll_head(self.head,&#34;head pointer shifts&#34;)
            self.algo.add_state(state)

    def __str__(self):
        return f&#34;LinkedList(head at {self.head})&#34;

    def __repr__(self):
        return f&#34;LinkedList(head at {self.head})&#34;

class ForwardListIterator:
    &#34;&#34;&#34;This class is a generator that is returned each time an ForwardList has
    to be iterated.

    Yields:
        Value of ForwardList Node

    Raises:
        AssertionError: If not declared with an instance of ARgorithmToolkit.linkedlist.ForwardList
    &#34;&#34;&#34;
    def __init__(self,forwardlist):
        assert isinstance(forwardlist,ForwardList)
        self._curr = forwardlist.head

    def __next__(self):
        if self._curr:
            data = self._curr.value
            self._curr = self._curr.next
            return data
        raise StopIteration

class ForwardList(LinkedList):
    &#34;&#34;&#34;The ForwardList class is proper implementation of singly linked list.

    The difference between LinkedList and ForwardList class is that ForwardList
    is a ready implementation of singly linked list. In the LinkedList class the
    programmer will have to make their own methods.

    Attributes:
        name (str): The name given to the linkedlist
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of ForwardList Class
        head (LinkedListNode): The referece to head of linkedlist
        size (int): Number of nodes i.e size of list

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)

    &#34;&#34;&#34;

    def __init__(self,name:str,algo:StateSet,comments=&#34;&#34;):
        super().__init__(name,algo,comments=&#34;&#34;)
        self.size = 0

    def __len__(self):
        &#34;&#34;&#34;overloads the len() operator to return size of list.

        Returns:
            int: size of list

        Example:

            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl.push_front(1)
            &gt;&gt;&gt; fl.size()
            1

        &#34;&#34;&#34;
        return self.size

    def insert(self,value,index=0):
        &#34;&#34;&#34;Insert node with given value at particular index. If index is not
        given,insert at front.

        Args:
            value : The value to be inserted
            index (int, optional): The index where value has to inserted . Defaults to 0.

        Example:

            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl.insert(2)
            &gt;&gt;&gt; fl.insert(4)
            &gt;&gt;&gt; fl.insert(3,1)
            &gt;&gt;&gt; fl
            ForwardList([4, 3, 2])

        &#34;&#34;&#34;
        if self.size == 0 or index == 0:
            self.push_front(value)
        elif self.size &lt; index:
            temp = self.head
            while temp.next:
                temp = temp.next
            curr = LinkedListNode(self.algo,value)
            temp.next = curr
            self.size += 1
        else:
            count = 1
            temp = self.head
            while index &gt; count:
                count += 1
                temp = temp.next
            curr = LinkedListNode(self.algo,value)
            curr.next = temp.next
            temp.next = curr
            self.size += 1

    def push_front(self,value):
        &#34;&#34;&#34;Pushes value to front.

        Args:
            value : Value to be appended to front

        Example:
            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl
            ForwardList([])
            &gt;&gt;&gt; fl.push_front(1)
            &gt;&gt;&gt; fl
            ForwardList([1])

        &#34;&#34;&#34;
        curr = LinkedListNode(self.algo,value)
        if self.head:
            curr.next = self.head
            self.head = curr
        else:
            curr.next = None
            self.head = curr
        self.size+=1

    def pop_front(self):
        &#34;&#34;&#34;Pops first element of forwardlist.

        Raises:
            ARgorithmError: Raised if list is empty

        Returns:
            element: The first element of list

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 1])
            &gt;&gt;&gt; fl.pop_front()
            2

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        data = self.head.value
        temp = self.head
        self.head = self.head.next
        del temp
        self.size -= 1
        return data

    def front(self):
        &#34;&#34;&#34;Returns the first element of list.

        Raises:
            ARgorithmError: Raised when list is empty

        Returns:
            element: The first element of list

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 1])
            &gt;&gt;&gt; fl.front()
            2

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        return self.head.value

    def __iter__(self):
        &#34;&#34;&#34;Returns the generator object to iterate through elements of
        ForwardList.

        Returns:
            ForwardListIterator: Generator class for ForwardList

        Example:

            &gt;&gt;&gt; [x for x in fl]
            [2, 2, 1]

        &#34;&#34;&#34;
        return ForwardListIterator(self)

    def remove(self,value):
        &#34;&#34;&#34;Remove elements with given value from list.

        Args:
            value : The value which has to be removed

        Raises:
            ARgorithmError: Raised if list is empty

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 2, 1])
            &gt;&gt;&gt; fl.remove(2)
            &gt;&gt;&gt; fl
            ForwardList([1])

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        while value == self.head.value:
            temp = self.head
            self.head = self.head.next
            del temp
            self.size -= 1
            if self.head is None:
                return
        curr = self.head
        while curr:
            if curr.next:
                if curr.next.value == value:
                    temp = curr.next
                    curr.next = curr.next.next
                    del temp
                    self.size -= 1
                    continue
            curr = curr.next

    def tolist(self):
        &#34;&#34;&#34;Converts the ForwardList to python list.

        Returns:
            list: list of ForwardList items

        Example:

            &gt;&gt;&gt; fl
            ForwardList([3, 1])
            &gt;&gt;&gt; fl.tolist()
            [3, 1]

        &#34;&#34;&#34;
        curr = self.head
        data = []
        while curr:
            data.append(curr.value)
            curr = curr.next
        return data

    def __repr__(self):
        return f&#34;ForwardList({self.tolist()})&#34;

    def __str__(self):
        return f&#34;ForwardList({self.tolist()})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ARgorithmToolkit.linkedlist.ForwardList"><code class="flex name class">
<span>class <span class="ident">ForwardList</span></span>
<span>(</span><span>name: str, algo: <a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a>, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>The ForwardList class is proper implementation of singly linked list.</p>
<p>The difference between LinkedList and ForwardList class is that ForwardList
is a ready implementation of singly linked list. In the LinkedList class the
programmer will have to make their own methods.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name given to the linkedlist</dd>
<dt><strong><code>algo</code></strong> :&ensp;<code><a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a></code></dt>
<dd>The stateset that will store the states generated by the instance of ForwardList Class</dd>
<dt><strong><code>head</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The referece to head of linkedlist</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of nodes i.e size of list</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised if algo is not of type StateSet</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&quot;fl&quot;,algo)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForwardList(LinkedList):
    &#34;&#34;&#34;The ForwardList class is proper implementation of singly linked list.

    The difference between LinkedList and ForwardList class is that ForwardList
    is a ready implementation of singly linked list. In the LinkedList class the
    programmer will have to make their own methods.

    Attributes:
        name (str): The name given to the linkedlist
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of ForwardList Class
        head (LinkedListNode): The referece to head of linkedlist
        size (int): Number of nodes i.e size of list

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)

    &#34;&#34;&#34;

    def __init__(self,name:str,algo:StateSet,comments=&#34;&#34;):
        super().__init__(name,algo,comments=&#34;&#34;)
        self.size = 0

    def __len__(self):
        &#34;&#34;&#34;overloads the len() operator to return size of list.

        Returns:
            int: size of list

        Example:

            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl.push_front(1)
            &gt;&gt;&gt; fl.size()
            1

        &#34;&#34;&#34;
        return self.size

    def insert(self,value,index=0):
        &#34;&#34;&#34;Insert node with given value at particular index. If index is not
        given,insert at front.

        Args:
            value : The value to be inserted
            index (int, optional): The index where value has to inserted . Defaults to 0.

        Example:

            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl.insert(2)
            &gt;&gt;&gt; fl.insert(4)
            &gt;&gt;&gt; fl.insert(3,1)
            &gt;&gt;&gt; fl
            ForwardList([4, 3, 2])

        &#34;&#34;&#34;
        if self.size == 0 or index == 0:
            self.push_front(value)
        elif self.size &lt; index:
            temp = self.head
            while temp.next:
                temp = temp.next
            curr = LinkedListNode(self.algo,value)
            temp.next = curr
            self.size += 1
        else:
            count = 1
            temp = self.head
            while index &gt; count:
                count += 1
                temp = temp.next
            curr = LinkedListNode(self.algo,value)
            curr.next = temp.next
            temp.next = curr
            self.size += 1

    def push_front(self,value):
        &#34;&#34;&#34;Pushes value to front.

        Args:
            value : Value to be appended to front

        Example:
            &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
            &gt;&gt;&gt; fl
            ForwardList([])
            &gt;&gt;&gt; fl.push_front(1)
            &gt;&gt;&gt; fl
            ForwardList([1])

        &#34;&#34;&#34;
        curr = LinkedListNode(self.algo,value)
        if self.head:
            curr.next = self.head
            self.head = curr
        else:
            curr.next = None
            self.head = curr
        self.size+=1

    def pop_front(self):
        &#34;&#34;&#34;Pops first element of forwardlist.

        Raises:
            ARgorithmError: Raised if list is empty

        Returns:
            element: The first element of list

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 1])
            &gt;&gt;&gt; fl.pop_front()
            2

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        data = self.head.value
        temp = self.head
        self.head = self.head.next
        del temp
        self.size -= 1
        return data

    def front(self):
        &#34;&#34;&#34;Returns the first element of list.

        Raises:
            ARgorithmError: Raised when list is empty

        Returns:
            element: The first element of list

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 1])
            &gt;&gt;&gt; fl.front()
            2

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        return self.head.value

    def __iter__(self):
        &#34;&#34;&#34;Returns the generator object to iterate through elements of
        ForwardList.

        Returns:
            ForwardListIterator: Generator class for ForwardList

        Example:

            &gt;&gt;&gt; [x for x in fl]
            [2, 2, 1]

        &#34;&#34;&#34;
        return ForwardListIterator(self)

    def remove(self,value):
        &#34;&#34;&#34;Remove elements with given value from list.

        Args:
            value : The value which has to be removed

        Raises:
            ARgorithmError: Raised if list is empty

        Example:

            &gt;&gt;&gt; fl
            ForwardList([2, 2, 1])
            &gt;&gt;&gt; fl.remove(2)
            &gt;&gt;&gt; fl
            ForwardList([1])

        &#34;&#34;&#34;
        if self.head is None:
            raise ARgorithmError(&#34;Empty list&#34;)
        while value == self.head.value:
            temp = self.head
            self.head = self.head.next
            del temp
            self.size -= 1
            if self.head is None:
                return
        curr = self.head
        while curr:
            if curr.next:
                if curr.next.value == value:
                    temp = curr.next
                    curr.next = curr.next.next
                    del temp
                    self.size -= 1
                    continue
            curr = curr.next

    def tolist(self):
        &#34;&#34;&#34;Converts the ForwardList to python list.

        Returns:
            list: list of ForwardList items

        Example:

            &gt;&gt;&gt; fl
            ForwardList([3, 1])
            &gt;&gt;&gt; fl.tolist()
            [3, 1]

        &#34;&#34;&#34;
        curr = self.head
        data = []
        while curr:
            data.append(curr.value)
            curr = curr.next
        return data

    def __repr__(self):
        return f&#34;ForwardList({self.tolist()})&#34;

    def __str__(self):
        return f&#34;ForwardList({self.tolist()})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ARgorithmToolkit.linkedlist.LinkedList" href="#ARgorithmToolkit.linkedlist.LinkedList">LinkedList</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first element of list.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised when list is empty</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>element</code></dt>
<dd>The first element of list</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl
ForwardList([2, 1])
&gt;&gt;&gt; fl.front()
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def front(self):
    &#34;&#34;&#34;Returns the first element of list.

    Raises:
        ARgorithmError: Raised when list is empty

    Returns:
        element: The first element of list

    Example:

        &gt;&gt;&gt; fl
        ForwardList([2, 1])
        &gt;&gt;&gt; fl.front()
        2

    &#34;&#34;&#34;
    if self.head is None:
        raise ARgorithmError(&#34;Empty list&#34;)
    return self.head.value</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, value, index=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert node with given value at particular index. If index is not
given,insert at front.</p>
<h2 id="args">Args</h2>
<dl>
<dt>value : The value to be inserted</dt>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The index where value has to inserted . Defaults to 0.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&quot;fl&quot;,algo)
&gt;&gt;&gt; fl.insert(2)
&gt;&gt;&gt; fl.insert(4)
&gt;&gt;&gt; fl.insert(3,1)
&gt;&gt;&gt; fl
ForwardList([4, 3, 2])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self,value,index=0):
    &#34;&#34;&#34;Insert node with given value at particular index. If index is not
    given,insert at front.

    Args:
        value : The value to be inserted
        index (int, optional): The index where value has to inserted . Defaults to 0.

    Example:

        &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
        &gt;&gt;&gt; fl.insert(2)
        &gt;&gt;&gt; fl.insert(4)
        &gt;&gt;&gt; fl.insert(3,1)
        &gt;&gt;&gt; fl
        ForwardList([4, 3, 2])

    &#34;&#34;&#34;
    if self.size == 0 or index == 0:
        self.push_front(value)
    elif self.size &lt; index:
        temp = self.head
        while temp.next:
            temp = temp.next
        curr = LinkedListNode(self.algo,value)
        temp.next = curr
        self.size += 1
    else:
        count = 1
        temp = self.head
        while index &gt; count:
            count += 1
            temp = temp.next
        curr = LinkedListNode(self.algo,value)
        curr.next = temp.next
        temp.next = curr
        self.size += 1</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.pop_front"><code class="name flex">
<span>def <span class="ident">pop_front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops first element of forwardlist.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised if list is empty</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>element</code></dt>
<dd>The first element of list</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl
ForwardList([2, 1])
&gt;&gt;&gt; fl.pop_front()
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_front(self):
    &#34;&#34;&#34;Pops first element of forwardlist.

    Raises:
        ARgorithmError: Raised if list is empty

    Returns:
        element: The first element of list

    Example:

        &gt;&gt;&gt; fl
        ForwardList([2, 1])
        &gt;&gt;&gt; fl.pop_front()
        2

    &#34;&#34;&#34;
    if self.head is None:
        raise ARgorithmError(&#34;Empty list&#34;)
    data = self.head.value
    temp = self.head
    self.head = self.head.next
    del temp
    self.size -= 1
    return data</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.push_front"><code class="name flex">
<span>def <span class="ident">push_front</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Pushes value to front.</p>
<h2 id="args">Args</h2>
<p>value : Value to be appended to front</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&quot;fl&quot;,algo)
&gt;&gt;&gt; fl
ForwardList([])
&gt;&gt;&gt; fl.push_front(1)
&gt;&gt;&gt; fl
ForwardList([1])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_front(self,value):
    &#34;&#34;&#34;Pushes value to front.

    Args:
        value : Value to be appended to front

    Example:
        &gt;&gt;&gt; fl = ARgorithmToolkit.ForwardList(&#34;fl&#34;,algo)
        &gt;&gt;&gt; fl
        ForwardList([])
        &gt;&gt;&gt; fl.push_front(1)
        &gt;&gt;&gt; fl
        ForwardList([1])

    &#34;&#34;&#34;
    curr = LinkedListNode(self.algo,value)
    if self.head:
        curr.next = self.head
        self.head = curr
    else:
        curr.next = None
        self.head = curr
    self.size+=1</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove elements with given value from list.</p>
<h2 id="args">Args</h2>
<p>value : The value which has to be removed</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised if list is empty</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl
ForwardList([2, 2, 1])
&gt;&gt;&gt; fl.remove(2)
&gt;&gt;&gt; fl
ForwardList([1])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self,value):
    &#34;&#34;&#34;Remove elements with given value from list.

    Args:
        value : The value which has to be removed

    Raises:
        ARgorithmError: Raised if list is empty

    Example:

        &gt;&gt;&gt; fl
        ForwardList([2, 2, 1])
        &gt;&gt;&gt; fl.remove(2)
        &gt;&gt;&gt; fl
        ForwardList([1])

    &#34;&#34;&#34;
    if self.head is None:
        raise ARgorithmError(&#34;Empty list&#34;)
    while value == self.head.value:
        temp = self.head
        self.head = self.head.next
        del temp
        self.size -= 1
        if self.head is None:
            return
    curr = self.head
    while curr:
        if curr.next:
            if curr.next.value == value:
                temp = curr.next
                curr.next = curr.next.next
                del temp
                self.size -= 1
                continue
        curr = curr.next</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardList.tolist"><code class="name flex">
<span>def <span class="ident">tolist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the ForwardList to python list.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of ForwardList items</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fl
ForwardList([3, 1])
&gt;&gt;&gt; fl.tolist()
[3, 1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tolist(self):
    &#34;&#34;&#34;Converts the ForwardList to python list.

    Returns:
        list: list of ForwardList items

    Example:

        &gt;&gt;&gt; fl
        ForwardList([3, 1])
        &gt;&gt;&gt; fl.tolist()
        [3, 1]

    &#34;&#34;&#34;
    curr = self.head
    data = []
    while curr:
        data.append(curr.value)
        curr = curr.next
    return data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ARgorithmToolkit.linkedlist.ForwardListIterator"><code class="flex name class">
<span>class <span class="ident">ForwardListIterator</span></span>
<span>(</span><span>forwardlist)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is a generator that is returned each time an ForwardList has
to be iterated.</p>
<h2 id="yields">Yields</h2>
<p>Value of ForwardList Node</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>If not declared with an instance of ARgorithmToolkit.linkedlist.ForwardList</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForwardListIterator:
    &#34;&#34;&#34;This class is a generator that is returned each time an ForwardList has
    to be iterated.

    Yields:
        Value of ForwardList Node

    Raises:
        AssertionError: If not declared with an instance of ARgorithmToolkit.linkedlist.ForwardList
    &#34;&#34;&#34;
    def __init__(self,forwardlist):
        assert isinstance(forwardlist,ForwardList)
        self._curr = forwardlist.head

    def __next__(self):
        if self._curr:
            data = self._curr.value
            self._curr = self._curr.next
            return data
        raise StopIteration</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedList"><code class="flex name class">
<span>class <span class="ident">LinkedList</span></span>
<span>(</span><span>name: str, algo: <a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a>, head=None, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>The LinkedList class is used to just store the head of the linked list.</p>
<p>This class is useful when programmer want to program his own List class using
the nodes. Only contains head attribute and no methods</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name given to the linkedlist</dd>
<dt><strong><code>algo</code></strong> :&ensp;<code><a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a></code></dt>
<dd>The stateset that will store the states generated by the instance of LinkedList Class</dd>
<dt><strong><code>head</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The referece to head of linkedlist</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised if algo is not of type StateSet</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ll = ARgorithmToolkit.LinkedList(&quot;llnode&quot;,algo)
&gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
&gt;&gt;&gt; ll.head = llnode
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkedList:
    &#34;&#34;&#34;The LinkedList class is used to just store the head of the linked list.

    This class is useful when programmer want to program his own List class using
    the nodes. Only contains head attribute and no methods

    Attributes:
        name (str): The name given to the linkedlist
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedList Class
        head (LinkedListNode): The referece to head of linkedlist

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; ll = ARgorithmToolkit.LinkedList(&#34;llnode&#34;,algo)
        &gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; ll.head = llnode

    &#34;&#34;&#34;

    def __init__(self,name:str,algo:StateSet,head=None,comments=&#34;&#34;):

        assert isinstance(name,str) , ARgorithmError(&#34;Name should be of type string&#34;)
        self.name = name
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError(&#34;algo should be of type StateSet&#34;) from e
        self.state_generator = LinkedListState(self.name)

        self._flag = False
        if head:
            assert self.algo == head.algo, ARgorithmError(&#34;The head node belongs to a different StateSet&#34;)
        self.head = head
        self._flag = True

        state = self.state_generator.ll_declare(self.head,comments)
        self.algo.add_state(state)

    def __setattr__(self,key,value):
        &#34;&#34;&#34;The __setattr__ function is overriden to listen to state changes in
        the head.

        Raises:
            ARgorithmError: Raised if head pointer is not type None or LinkedListNode
        &#34;&#34;&#34;
        if key == &#39;head&#39; and value:
            assert isinstance(value,LinkedListNode) , ARgorithmError(&#34;next should be of type None or LinkedListNode&#34;)
        self.__dict__[key] = value
        if key == &#39;head&#39; and self._flag:
            state = self.state_generator.ll_head(self.head,&#34;head pointer shifts&#34;)
            self.algo.add_state(state)

    def __str__(self):
        return f&#34;LinkedList(head at {self.head})&#34;

    def __repr__(self):
        return f&#34;LinkedList(head at {self.head})&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ARgorithmToolkit.linkedlist.ForwardList" href="#ARgorithmToolkit.linkedlist.ForwardList">ForwardList</a></li>
</ul>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNode"><code class="flex name class">
<span>class <span class="ident">LinkedListNode</span></span>
<span>(</span><span>algo: <a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a>, value=None, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>The LinkedListNode class is an implementation of a Linked list Node for
which we store states. Unlike other data structure classes, in which we
have to give a name to the instance, we dont have to provide name in the
LinkedListNode Class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>algo</code></strong> :&ensp;<code><a title="ARgorithmToolkit.utils.StateSet" href="utils.html#ARgorithmToolkit.utils.StateSet">StateSet</a></code></dt>
<dd>The stateset that will store the states generated by the instance of LinkedListNode Class</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value stored in the node</dd>
<dt><strong><code>next</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The reference to next node</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ARgorithmError</code></dt>
<dd>Raised if algo is not of type StateSet</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
&gt;&gt;&gt; llnode.value = 10
&gt;&gt;&gt; temp = = ARgorithmToolkit.LinkedListNode(algo,7)
&gt;&gt;&gt; temp.next = llnode
&gt;&gt;&gt; llnode = temp
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkedListNode:
    &#34;&#34;&#34;The LinkedListNode class is an implementation of a Linked list Node for
    which we store states. Unlike other data structure classes, in which we
    have to give a name to the instance, we dont have to provide name in the
    LinkedListNode Class.

    Attributes:
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedListNode Class
        value: The value stored in the node
        next (LinkedListNode): The reference to next node

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        &gt;&gt;&gt; llnode = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; llnode.value = 10
        &gt;&gt;&gt; temp = = ARgorithmToolkit.LinkedListNode(algo,7)
        &gt;&gt;&gt; temp.next = llnode
        &gt;&gt;&gt; llnode = temp

    &#34;&#34;&#34;

    def __init__(self,algo:StateSet,value=None,comments=&#34;&#34;):
        self.name = id(self)
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError(&#34;algo should be of type StateSet&#34;) from e

        self.state_generator = LinkedListNodeState(self.name)

        self._flag = False
        self.value = value
        self.next = None
        self._flag = True

        state = self.state_generator.llnode_declare(
            self.value,self.next,comments
        )
        self.algo.add_state(state)

    def __setattr__(self,key,value):
        &#34;&#34;&#34;The __setattr__ function is overriden to listen to state changes in
        the value of node or the next attribute.

        Raises:
            ARgorithmError: Raised if next pointer is not type None or LinkedListNode
        &#34;&#34;&#34;
        if key == &#39;next&#39; and value:
            assert isinstance(value,LinkedListNode) , ARgorithmError(&#34;next should be of type None or LinkedListNode&#34;)
        self.__dict__[key] = value
        if key == &#39;next&#39; and self._flag:
            if value or self.next:
                state = self.state_generator.llnode_next(
                    self.value,
                    self.next,
                    &#34;next pointer updated&#34;
                )
                self.algo.add_state(state)
        elif key == &#39;value&#39; and self._flag:
            state = self.state_generator.llnode_iter(
                self.value,
                self.next,
                &#34;value updated&#34;
            )
            self.algo.add_state(state)

    def __del__(self):
        &#34;&#34;&#34;The __del__ function is overriden is there to listen to node
        deletion.&#34;&#34;&#34;
        state = self.state_generator.llnode_delete(
            &#34;Node was deleted&#34;
        )
        self.algo.add_state(state)

    def __str__(self):
        return f&#34;LinkedListNode({self.value}) at {self.name}&#34;

    def __repr__(self):
        return f&#34;LinkedListNode({self.value}) at {self.name}&#34;</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNodeState"><code class="flex name class">
<span>class <span class="ident">LinkedListNodeState</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to generate states for various actions performed on
the <code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code> object.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str) : Name of the variable for whom we are generating states</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkedListNodeState:
    &#34;&#34;&#34;This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedListNode`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
    &#34;&#34;&#34;

    def __init__(self,name:str):
        self.name = name

    def llnode_declare(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_declare` state when a new node is created.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_declare` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_declare&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_iter(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_iter` state when a node is accessed or its
        value is changed.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_iter` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_iter&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_next(self,value,_next,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_next` state when the next pointer changes.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_next` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_next&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;value&#34; : value,
            &#34;next&#34; : _next.name if _next else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_delete(self,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `llnode_delete` state when a node is deleted.

        Args:
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `llnode_delete` state
        &#34;&#34;&#34;
        state_type = &#34;llnode_delete&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_declare"><code class="name flex">
<span>def <span class="ident">llnode_declare</span></span>(<span>self, value, _next, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>llnode_declare</code> state when a new node is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt>value : The value stored in the linkedlist node</dt>
<dt><strong><code>next</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The next pointer</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>llnode_declare</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llnode_declare(self,value,_next,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `llnode_declare` state when a new node is created.

    Args:
        value : The value stored in the linkedlist node
        next (LinkedListNode): The next pointer
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `llnode_declare` state
    &#34;&#34;&#34;
    state_type = &#34;llnode_declare&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
        &#34;value&#34; : value,
        &#34;next&#34; : _next.name if _next else &#34;none&#34;
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_delete"><code class="name flex">
<span>def <span class="ident">llnode_delete</span></span>(<span>self, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>llnode_delete</code> state when a node is deleted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>llnode_delete</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llnode_delete(self,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `llnode_delete` state when a node is deleted.

    Args:
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `llnode_delete` state
    &#34;&#34;&#34;
    state_type = &#34;llnode_delete&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_iter"><code class="name flex">
<span>def <span class="ident">llnode_iter</span></span>(<span>self, value, _next, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>llnode_iter</code> state when a node is accessed or its
value is changed.</p>
<h2 id="args">Args</h2>
<dl>
<dt>value : The value stored in the linkedlist node</dt>
<dt><strong><code>next</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The next pointer</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>llnode_iter</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llnode_iter(self,value,_next,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `llnode_iter` state when a node is accessed or its
    value is changed.

    Args:
        value : The value stored in the linkedlist node
        next (LinkedListNode): The next pointer
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `llnode_iter` state
    &#34;&#34;&#34;
    state_type = &#34;llnode_iter&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
        &#34;value&#34; : value,
        &#34;next&#34; : _next.name if _next else &#34;none&#34;
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_next"><code class="name flex">
<span>def <span class="ident">llnode_next</span></span>(<span>self, value, _next, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>llnode_next</code> state when the next pointer changes.</p>
<h2 id="args">Args</h2>
<dl>
<dt>value : The value stored in the linkedlist node</dt>
<dt><strong><code>next</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The next pointer</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>llnode_next</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def llnode_next(self,value,_next,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `llnode_next` state when the next pointer changes.

    Args:
        value : The value stored in the linkedlist node
        next (LinkedListNode): The next pointer
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `llnode_next` state
    &#34;&#34;&#34;
    state_type = &#34;llnode_next&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
        &#34;value&#34; : value,
        &#34;next&#34; : _next.name if _next else &#34;none&#34;
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListState"><code class="flex name class">
<span>class <span class="ident">LinkedListState</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to generate states for various actions performed on
the <code><a title="ARgorithmToolkit.linkedlist.LinkedList" href="#ARgorithmToolkit.linkedlist.LinkedList">LinkedList</a></code> object.</p>
<h2 id="attributes">Attributes</h2>
<p>name (str) : Name of the variable for whom we are generating states</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkedListState:
    &#34;&#34;&#34;This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedList`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
    &#34;&#34;&#34;
    def __init__(self,name:str):
        self.name = name

    def ll_declare(self,head,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `ll_declare` state when a new linkedlist is created.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `ll_declare` state
        &#34;&#34;&#34;
        state_type = &#34;ll_declare&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;head&#34; : head.name if head else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def ll_head(self,head,comments=&#34;&#34;):
        &#34;&#34;&#34;Generates the `ll_head` state when linkedlist head is changed.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

        Returns:
            State: Returns the `ll_head` state
        &#34;&#34;&#34;
        state_type = &#34;ll_head&#34;
        state_def = {
            &#34;variable_name&#34; : self.name,
            &#34;head&#34; : head.name if head else &#34;none&#34;
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ARgorithmToolkit.linkedlist.LinkedListState.ll_declare"><code class="name flex">
<span>def <span class="ident">ll_declare</span></span>(<span>self, head, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>ll_declare</code> state when a new linkedlist is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The head pointer</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>ll_declare</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ll_declare(self,head,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `ll_declare` state when a new linkedlist is created.

    Args:
        head (LinkedListNode): The head pointer
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `ll_declare` state
    &#34;&#34;&#34;
    state_type = &#34;ll_declare&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
        &#34;head&#34; : head.name if head else &#34;none&#34;
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
<dt id="ARgorithmToolkit.linkedlist.LinkedListState.ll_head"><code class="name flex">
<span>def <span class="ident">ll_head</span></span>(<span>self, head, comments='')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the <code>ll_head</code> state when linkedlist head is changed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></dt>
<dd>The head pointer</dd>
<dt><strong><code>comments</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Comments for descriptive purpose. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>State</code></dt>
<dd>Returns the <code>ll_head</code> state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ll_head(self,head,comments=&#34;&#34;):
    &#34;&#34;&#34;Generates the `ll_head` state when linkedlist head is changed.

    Args:
        head (LinkedListNode): The head pointer
        comments (str, optional): Comments for descriptive purpose. Defaults to &#34;&#34;.

    Returns:
        State: Returns the `ll_head` state
    &#34;&#34;&#34;
    state_type = &#34;ll_head&#34;
    state_def = {
        &#34;variable_name&#34; : self.name,
        &#34;head&#34; : head.name if head else &#34;none&#34;
    }
    return State(
        state_type=state_type,
        state_def=state_def,
        comments=comments
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@500&display=swap');
#back {
box-sizing: border-box;
padding: 5px;
background-color: #dadada;
color: black;
border-radius: 5px;
font-family: 'IBM Plex Sans', sans-serif;
text-decoration: none;
}
</style>
<a href='/toolkit' id="back">
<i class="fa fa-home" aria-hidden="true"></i> Back
</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ARgorithmToolkit" href="index.html">ARgorithmToolkit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.ForwardList" href="#ARgorithmToolkit.linkedlist.ForwardList">ForwardList</a></code></h4>
<ul class="two-column">
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.front" href="#ARgorithmToolkit.linkedlist.ForwardList.front">front</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.insert" href="#ARgorithmToolkit.linkedlist.ForwardList.insert">insert</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.pop_front" href="#ARgorithmToolkit.linkedlist.ForwardList.pop_front">pop_front</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.push_front" href="#ARgorithmToolkit.linkedlist.ForwardList.push_front">push_front</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.remove" href="#ARgorithmToolkit.linkedlist.ForwardList.remove">remove</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.ForwardList.tolist" href="#ARgorithmToolkit.linkedlist.ForwardList.tolist">tolist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.ForwardListIterator" href="#ARgorithmToolkit.linkedlist.ForwardListIterator">ForwardListIterator</a></code></h4>
</li>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.LinkedList" href="#ARgorithmToolkit.linkedlist.LinkedList">LinkedList</a></code></h4>
</li>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.LinkedListNode" href="#ARgorithmToolkit.linkedlist.LinkedListNode">LinkedListNode</a></code></h4>
</li>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.LinkedListNodeState" href="#ARgorithmToolkit.linkedlist.LinkedListNodeState">LinkedListNodeState</a></code></h4>
<ul class="">
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_declare" href="#ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_declare">llnode_declare</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_delete" href="#ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_delete">llnode_delete</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_iter" href="#ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_iter">llnode_iter</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_next" href="#ARgorithmToolkit.linkedlist.LinkedListNodeState.llnode_next">llnode_next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ARgorithmToolkit.linkedlist.LinkedListState" href="#ARgorithmToolkit.linkedlist.LinkedListState">LinkedListState</a></code></h4>
<ul class="">
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListState.ll_declare" href="#ARgorithmToolkit.linkedlist.LinkedListState.ll_declare">ll_declare</a></code></li>
<li><code><a title="ARgorithmToolkit.linkedlist.LinkedListState.ll_head" href="#ARgorithmToolkit.linkedlist.LinkedListState.ll_head">ll_head</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>